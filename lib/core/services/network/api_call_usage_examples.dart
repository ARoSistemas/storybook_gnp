import 'dart:convert';
import 'dart:developer';
import 'dart:io';
import 'dart:typed_data';

import 'package:storybook_gnp/core/config/constans.dart';
import 'package:storybook_gnp/core/services/network/api_call.dart';
import 'package:storybook_gnp/core/services/network/api_response.dart';
import 'package:storybook_gnp/core/services/network/api_response_failure.dart';
import 'package:storybook_gnp/core/services/network/api_response_success.dart';

/// üöÄ Ejemplos de uso de ApiCall con soporte para archivos
///
/// Esta clase demuestra c√≥mo usar la implementaci√≥n de ApiCall
/// con endpoints din√°micos y soporte para descargas de archivos
class ApiCallUsageExamples {
  final ApiCallAbstract _apiCall = ApiCallImpl();

  /// ‚úÖ Ejemplo b√°sico: GET request
  Future<ApiResponse<ApiFailure, ApiSuccess>> getMovies(
    String bearerToken,
  ) => _apiCall.call(
    baseUri: baseUrl, // desde constants.dart
    endpoint: '/3/movie/popular',
    bearer: bearerToken,
    body: '',
    epName: 'GetPopularMovies',
    queryParameters: {
      'api_key': 'api_key',
      'language': 'es-ES',
    },
  );

  /// ‚úÖ Ejemplo b√°sico: POST request
  Future<ApiResponse<ApiFailure, ApiSuccess>> createUser(
    String bearerToken,
    Map<String, dynamic> userData,
  ) => _apiCall.call(
    baseUri: baseUrl, // desde constants.dart
    endpoint: '/users',
    bearer: bearerToken,
    body: jsonEncode(userData),
    epName: 'CreateUser',
    method: HttpMethod.post,
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    },
  );

  /// üì• NUEVO: Download de archivo (devuelve base64)
  Future<ApiResponse<ApiFailure, ApiSuccess>> downloadFile(
    String bearerToken,
    String fileId,
  ) => _apiCall.downloadFile(
    baseUri: baseUrl,
    endpoint: '/files/$fileId/download',
    bearer: bearerToken,
    epName: 'DownloadFile',
    queryParameters: {
      'format': 'original',
      'compression': 'none',
    },
  );

  /// üì• Ejemplo COMPLETO: Descarga y guardado de archivo
  Future<bool> downloadAndSaveFile(
    String bearerToken,
    String fileId,
    String savePath,
  ) async {
    try {
      log('üì• Iniciando descarga del archivo $fileId...');

      final ApiResponse<ApiFailure, ApiSuccess> response = await downloadFile(
        bearerToken,
        fileId,
      );

      return await response.when(
        (failure) {
          log('‚ùå Error descargando archivo: ${failure.message}');
          log('üìä C√≥digo de error: ${failure.code}');
          return false;
        },
        (success) {
          try {
            log('‚úÖ Descarga exitosa, procesando archivo...');

            // success.data contiene el archivo en base64
            final Uint8List bytes = base64Decode(success.data);

            // Crear directorio si no existe
            // final file = File(savePath);
            // final Directory directory = file.parent;
            // if (!await directory.exists()) {
            //   await directory.create(recursive: true);
            //   log('üìÅ Directorio creado: ${directory.path}');
            // }

            // Guardar archivo
            // await file.writeAsBytes(bytes);

            log('‚úÖ Archivo guardado exitosamente:');
            log('   üìç Ruta: $savePath');
            log('   üìä Tama√±o: ${bytes.length} bytes');
            log('   üìÖ Fecha: ${DateTime.now()}');

            return true;
          } on Exception catch (e) {
            log('‚ùå Error guardando archivo: $e');
            return false;
          }
        },
      );
    } on Exception catch (e) {
      log('‚ùå Error general en descarga: $e');
      return false;
    }
  }

  /// üì§ Upload b√°sico usando JSON (para APIs que aceptan base64)
  Future<ApiResponse<ApiFailure, ApiSuccess>> uploadFileAsBase64(
    String bearerToken,
    File file,
    String fileName,
  ) async {
    try {
      // Leer archivo y convertir a base64
      final Uint8List bytes = await file.readAsBytes();
      final String base64Content = base64Encode(bytes);

      final Map<String, Object> uploadData = {
        'filename': fileName,
        'content': base64Content,
        'size': bytes.length,
        'mimeType': _getMimeType(fileName),
        'uploadedAt': DateTime.now().toIso8601String(),
      };

      return await _apiCall.call(
        baseUri: baseUrl,
        endpoint: '/upload/base64',
        bearer: bearerToken,
        body: jsonEncode(uploadData),
        epName: 'UploadFileBase64',
        method: HttpMethod.post,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      );
    } on Exception catch (e) {
      // Crear response de error manual
      return ApiResponse.failure(
        ApiFailure(
          message: 'Error preparando archivo para upload: $e',
        ),
      );
    }
  }

  /// üîÑ Upload con reintentos autom√°ticos
  Future<bool> uploadWithRetry(
    String bearerToken,
    File file,
    String fileName, {
    int maxRetries = 3,
  }) async {
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
      log('üîÑ Intento $attempt de $maxRetries para $fileName');

      try {
        final ApiResponse<ApiFailure, ApiSuccess> response =
            await uploadFileAsBase64(bearerToken, file, fileName);

        final bool success = await response.when(
          (failure) {
            log('‚ùå Intento $attempt fall√≥: ${failure.message}');
            return false;
          },
          (success) {
            log('‚úÖ Upload exitoso en intento $attempt');
            log('üìÑ Respuesta del servidor: ${success.data}');
            return true;
          },
        );

        if (success) {
          return true;
        }

        // Espera exponencial entre intentos
        if (attempt < maxRetries) {
          final waitTime = Duration(seconds: attempt * 2);
          log(
            '‚è≥ Esperando ${waitTime.inSeconds}s antes del siguiente intento...',
          );
          await Future.delayed(waitTime);
        }
      } on Exception catch (e) {
        log('‚ùå Error en intento $attempt: $e');
        if (attempt == maxRetries) {
          log('‚ùå Todos los intentos fallaron');
          return false;
        }
      }
    }

    return false;
  }

  /// üìä Ejemplo de uso con monitoreo completo
  Future<void> demonstrateFileOperations() async {
    const bearerToken = 'tu_bearer_token_aqui';

    log(r'üöÄ === DEMOSTRACI√ìN DE OPERACIONES CON ARCHIVOS ===\n');

    // 1. Download de archivo
    log('üì• 1. Descargando archivo...');
    final bool downloadSuccess = await downloadAndSaveFile(
      bearerToken,
      'file123',
      'downloads/document.pdf',
    );

    if (downloadSuccess) {
      log(r'‚úÖ Descarga completada\n');
    } else {
      log(r'‚ùå Descarga fall√≥\n');
    }

    // 2. Upload de archivo
    log('üì§ 2. Subiendo archivo...');
    final testFile = File('test_document.txt');

    // Crear archivo de prueba si no existe
    // if (!await testFile.exists()) {
    //await testFile.writeAsString('Este es un archivo de prueba para upload');
    // }

    final bool uploadSuccess = await uploadWithRetry(
      bearerToken,
      testFile,
      'test_document.txt',
    );

    if (uploadSuccess) {
      log(r'‚úÖ Upload completado\n');
    } else {
      log(r'‚ùå Upload fall√≥\n');
    }

    log('üéâ === DEMOSTRACI√ìN COMPLETADA ===');
  }

  /// Utilidad: Obtener MIME type b√°sico
  String _getMimeType(String fileName) {
    final String extension = fileName.split('.').last.toLowerCase();
    switch (extension) {
      case 'pdf':
        return 'application/pdf';
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'txt':
        return 'text/plain';
      case 'json':
        return 'application/json';
      case 'xml':
        return 'application/xml';
      case 'zip':
        return 'application/zip';
      default:
        return 'application/octet-stream';
    }
  }
}

/// üîß Ejemplos de uso directo (sin wrapper)
class DirectApiCallExamples {
  /// üì• Download directo con manejo completo
  static Future<void> directDownload() async {
    final ApiCallAbstract apiCall = ApiCallImpl();
    const bearerToken = 'tu_bearer_token';

    log('üì• Iniciando descarga directa...');
    final stopwatch = Stopwatch()..start();

    final ApiResponse<ApiFailure, ApiSuccess> response = await apiCall
        .downloadFile(
          baseUri: baseUrl,
          endpoint: '/documents/important.pdf',
          bearer: bearerToken,
          epName: 'DirectDownload',
          queryParameters: {
            'version': 'latest',
            'format': 'pdf',
          },
        );

    stopwatch.stop();
    log('‚è±Ô∏è Tiempo de descarga: ${stopwatch.elapsedMilliseconds}ms');

    response.when(
      (failure) {
        log('‚ùå Download fall√≥: ${failure.message}');
        log('üìä C√≥digo de error: ${failure.code}');
      },
      (success) {
        final Uint8List bytes = base64Decode(success.data);
        log('‚úÖ Download exitoso:');
        log('   üìä Tama√±o: ${bytes.length} bytes');
        log('   üìÑ Tipo: PDF');

        // Guardar con timestamp
        final fileName =
            'important_${DateTime.now().millisecondsSinceEpoch}.pdf';
        File(fileName).writeAsBytesSync(bytes);
        log('   üíæ Guardado como: $fileName');
      },
    );
  }

  /// üì§ Upload directo JSON
  static Future<void> directUpload() async {
    final ApiCallAbstract apiCall = ApiCallImpl();
    const bearerToken = 'tu_bearer_token';

    // Crear datos de prueba
    final Map<String, String> testData = {
      'title': 'Documento de prueba',
      'content': 'Este es el contenido del documento',
      'author': 'Usuario de prueba',
      'createdAt': DateTime.now().toIso8601String(),
    };

    log('üì§ Iniciando upload directo...');

    final ApiResponse<ApiFailure, ApiSuccess> response = await apiCall.call(
      baseUri: baseUrl,
      endpoint: '/documents/create',
      bearer: bearerToken,
      body: jsonEncode(testData),
      epName: 'DirectUpload',
      method: HttpMethod.post,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    );

    response.when(
      (failure) {
        log('‚ùå Upload fall√≥: ${failure.message}');
        log('üìä C√≥digo de error: ${failure.code}');
      },
      (success) {
        log('‚úÖ Upload exitoso:');
        log('üìÑ Respuesta: ${success.data}');
        log('üìä C√≥digo: ${success.code}');
      },
    );
  }

  /// üîÑ Operaci√≥n completa: Create ‚Üí Upload ‚Üí Download
  static Future<void> completeWorkflow() async {
    final ApiCallAbstract apiCall = ApiCallImpl();
    const bearerToken = 'tu_bearer_token';

    log(r'üîÑ === WORKFLOW COMPLETO ===\\n');

    // 1. Crear documento
    log('1Ô∏è‚É£ Creando documento...');
    final ApiResponse<ApiFailure, ApiSuccess> createResponse = await apiCall
        .call(
          baseUri: baseUrl,
          endpoint: '/documents',
          bearer: bearerToken,
          body: jsonEncode({
            'title': 'Workflow Test Document',
            'description': 'Documento creado para probar el workflow completo',
          }),
          epName: 'CreateDocument',
          method: HttpMethod.post,
          headers: {'Content-Type': 'application/json'},
        );

    String? documentId;
    createResponse.when(
      (failure) => log('‚ùå Error creando documento: ${failure.message}'),
      (success) {
        final Map<String, dynamic> data = jsonDecode(success.data);
        documentId = data['id']?.toString();
        log('‚úÖ Documento creado con ID: $documentId');
      },
    );

    if (documentId != null) {
      // 2. Descargar documento
      log(r'\\n2Ô∏è‚É£ Descargando documento...');
      final ApiResponse<ApiFailure, ApiSuccess> downloadResponse = await apiCall
          .downloadFile(
            baseUri: baseUrl,
            endpoint: '/documents/$documentId/export',
            bearer: bearerToken,
            epName: 'ExportDocument',
          );

      downloadResponse.when(
        (failure) => log('‚ùå Error descargando: ${failure.message}'),
        (success) {
          final Uint8List bytes = base64Decode(success.data);
          log('‚úÖ Documento descargado: ${bytes.length} bytes');

          // Guardar archivo
          File('workflow_document.pdf').writeAsBytesSync(bytes);
          log('üíæ Guardado como: workflow_document.pdf');
        },
      );
    }

    log(r'\\nüéâ === WORKFLOW COMPLETADO ===');
  }
}
